function [data] = sem_read_fieldfile( varargin )
% [data] = sem_read_fieldfile( field_file_name, [indexes] )
%
% Reads the contents of the field file generated by the SMPM solver code.
%
% Takes 1 or 2 arguments:
%
%   field_file_name - String indicating the field file to read from disk.
%   indexes         - Optional indices of time-steps in the field file you
%                     want. Negative indices represent indexing from the end.
%                     I.e. -1 is the last index, -2 the second last, -3 the
%                     third last etc.  If omitted, defaults to all available.
%
% Returns 1 value:
%
%   data - Struct with fields as described below.
%
%     .grid.x    - Matrix, of size (mz * n) x (mx * n), containing the x-coordinates of
%                  the mesh associated with the field variables.
%     .grid.y    - Matrix, of size (my * n) x (mx * n), containing the z-coordinates of
%                  the mesh associated with the field variables.
%     .grid.z    - Matrix, of size (mz * n) x (mx * n), containing the z-coordinates of
%                  the mesh associated with the field variables.
%     .field.ux  - Matrix, of size (mz * n) x (mx * n) x ntime, containing the velocity
%                  in the x-direction for each time and grid point.
%     .field.uy  - Matrix, of size (mz * n) x (mx * n) x ntime, containing the velocity
%                  y-direction for each time and grid point.
%     .field.uz  - Matrix, of size (mz * n) x (mx * n) x ntime, containing the velocity
%                  z-direction for each time and grid point.
%     .field.rho - Matrix, of size (mz * n) x (mx * n) x ntime, containing the density for
%                  each time and grid point.

    % Parse the argument list.
    field_file_name = varargin{1};
    if ( nargin == 1 )
       indexes = [];
    else
       indexes = varargin{2};
    end

    % Get some information about this field file.
    info = sem_fieldfile_info( field_file_name );
    data.grid.x  = info.x;
    data.grid.y  = info.y;
    data.grid.z  = info.z;
    data.grid.n  = info.n;
    data.grid.mx = info.mx;
    data.grid.my = info.my;
    data.grid.mz = info.mz;
    number_of_timesteps = info.number_steps;

    % If no index array was provided, set it equal to the full range and quickly parse the data.
    if length( indexes ) == 0
       indexes = [1:number_of_timesteps];
    end

    % Check the index array to see if there are any negative indices, if so make them referenced to the beginning of the array.
    for ii = 1:length(indexes)

       % If this index is negative then re-compute it.
       if indexes(ii) < 0
          indexes(ii) = number_of_timesteps + indexes(ii) + 1;
       end

       % Just to make sure, if the indexes exceed the number of timesteps throw an error.
       if indexes(ii) > number_of_timesteps
           error( sprintf( 'Index %d exceeds the total number of time steps in file %s', ...
                           indexes(ii), field_file_name ) );
       end

    end

    % Pre-allocate the data arrays.
    data.field.ux = zeros( info.mx * info.n, info.my * info.n, info.mz * info.n, length( indexes ) );
    data.field.uy = zeros( info.mx * info.n, info.my * info.n, info.mz * info.n, length( indexes ) );
    data.field.uz = zeros( info.mx * info.n, info.my * info.n, info.mz * info.n, length( indexes ) );
    data.field.s  = zeros( info.mx * info.n, info.my * info.n, info.mz * info.n, length( indexes ) );

    % Loop over the data reading as desired.
    for ii = 1:length(indexes)

       % Make the string for reading data.
       readstr = [ '/field/step' num2str(indexes(ii)) '/'];

       % Read the data.
       data.field.ux(:,:,:,ii) = h5read( field_file_name, [readstr 'ux'] );
       data.field.uy(:,:,:,ii) = h5read( field_file_name, [readstr 'uy'] );
       data.field.uz(:,:,:,ii) = h5read( field_file_name, [readstr 'uz'] );
       data.field.s(:,:,:,ii)  = h5read( field_file_name, [readstr 's'] );

    end

end
